#!/usr/bin/env python
import click
import os
import json
import yaml
import subprocess
import sys
import textwrap
from itertools import islice, chain
from collections import OrderedDict

from typing import List, Optional, Dict, Any

def get_device_cfg_repo_root_dir() -> str:
    env_var_name = "PKG_NIXOS_SF_FACTORY_COMMON_INSTALL_DEVICE_OS_CONFIG_REPO_DIR"
    out = os.environ.get(env_var_name, None)
    if out is None:
        raise Exception((
            "ERROR: Env var '{}' "
            "should be set to point to the device "
            "configuration core repository!").format(
                env_var_name)
        )

    return out

def get_device_cfg_device_dir() -> str:
    out_dir = os.path.join(get_device_cfg_repo_root_dir(), "device")
    if not os.path.exists(out_dir):
        raise Exception("ERROR: Directory '{}' does not exists!".format(out_dir))
    return out_dir


def get_device_json_cfg_path(device_id: str) -> str:
    return os.path.join(get_device_cfg_device_dir(), device_id, "device.json")


def load_device_stored_cfg(device_id: str) -> Dict[str, Any]:
    json_cfg_path = get_device_json_cfg_path(device_id)
    with open(json_cfg_path) as f:
        # We want to preserve key order. Json already does that.
        out = json.load(f)

    assert out is not None
    return out


def sanitize_bash_path_out(in_path: bytes):
    return in_path.decode("utf-8").strip()


def collect_process_stdout(process_name: str, *args, **kwargs) -> str:
    cmd_w_args = [ process_name ]
    cmd_w_args.extend(args)
    return sanitize_bash_path_out(subprocess.check_output(cmd_w_args, **kwargs))


def prompt_for_user_approval(
        prompt_str: Optional[str] = None
) -> bool:
    if prompt_str is None:
        prompt_str="Continue"

    r = input("{} (y/n)? ".format(prompt_str))
    print("\n")
    approval_given = (r == 'Y' or r == 'y')
    return approval_given


def get_nixos_secure_factory_workspace_dir() -> str:
    ws_dir = collect_process_stdout("pkg-nixos-factory-common-install-get-workspace-dir")
    assert os.path.exists(ws_dir)
    return ws_dir


def get_current_device_store_yaml_filename() -> str:
    device_cfg_repo_root_dir = get_nixos_secure_factory_workspace_dir()
    return os.path.join(device_cfg_repo_root_dir, ".current-device.yaml")


def dump_as_current_device_cfg(
        in_cfg: Dict[str, Any],
        out_yaml_file_path: Optional[str] = None
) -> None:
    if out_yaml_file_path is None:
        out_yaml_file_path = get_current_device_store_yaml_filename()
    with open(out_yaml_file_path, 'w') as of:
        # We want to preserve key order, thus the `sort_keys=False`.
        yaml.safe_dump(in_cfg, of, sort_keys=False)


def format_cfg_as_yaml_str(in_cfg: Dict[str, Any]) -> str:
    # We want to preserve key order, thus the `sort_keys=False`.
    return yaml.safe_dump(in_cfg, sort_keys=False)


def list_available_device_ids() -> List[str]:
  root_dir = get_device_cfg_device_dir()
  out = list(chain.from_iterable(x[1] for x in islice(os.walk(root_dir), 0, 1)))
  return out


def match_device_id(
        search_str: str, available_devices: Optional[str] = None
) -> List[str]:
    if available_devices is None:
        available_devices = list_available_device_ids()
    out = [x for x in available_devices if x.startswith(search_str)]
    if out:
        return out

    return [x for x in available_devices if search_str in x]

def list_ac_available_device_ids(ctx, args, incomplete: str) -> List[str]:
    return match_device_id(incomplete)


def format_available_devices_str(devices: List[str]) -> str:
    devices_str = "\n".join(devices)
    available_devices_msg_str = (
        "Available devices\n"
        "------------------\n\n"
        "{}\n"
        ).format(devices_str)
    return available_devices_msg_str


def format_matching_devices_str(devices: List[str]) -> str:
    devices_str = "\n".join(devices)
    available_devices_msg_str = (
        "Matching devices\n"
        "----------------\n\n"
        "{}\n"
        ).format(devices_str)
    return available_devices_msg_str


class MatchNotUniqueError(Exception):
    pass


def match_unique_device_id(search_str: str) -> str:
    available_devices = list_available_device_ids()
    matching_devices = match_device_id(search_str, available_devices)
    if not matching_devices:
        available_devices_msg_str = format_available_devices_str(
            available_devices)
        raise MatchNotUniqueError((
            "ERROR: No device dirname match specified "
            "search string: '{}'.\n\n{}"
            ).format(
                search_str,
                available_devices_msg_str
            ))

    matching_count = len(matching_devices)
    if matching_count > 1:
        matching_devices_msg_str = format_matching_devices_str(matching_devices)
        raise MatchNotUniqueError((
            "ERROR: Too many dirname match for the specified "
            "search string: '{}'\n\n{}"
            ).format(
                search_str,
                matching_devices_msg_str
            ))

    assert matching_count == 1
    return matching_devices[0]


@click.command()
@click.argument(
    "device-id",
    type=click.STRING,
    autocompletion=list_ac_available_device_ids)
def cli(device_id) -> None:
    """Checkout a particular device state."""
    print((
        "Checking out device state\n"
        "=========================\n"
    ).format())
    try:
        matched_device_id = match_unique_device_id(device_id)
    except MatchNotUniqueError as e:
        print(e)
        sys.exit(1)

    device_cfg = load_device_stored_cfg(matched_device_id)

    device_cfg_yaml_str = format_cfg_as_yaml_str(device_cfg)
    print(textwrap.dedent('''\
        Device info
        -----------

        {}\
    ''').format(device_cfg_yaml_str))

    if not prompt_for_user_approval():
        sys.exit(1)

    store_yaml = get_current_device_store_yaml_filename()
    print("Writing device configuration to '{}'.".format(store_yaml))
    dump_as_current_device_cfg(device_cfg, store_yaml)
    print("Current device is now set to '{}'.".format(matched_device_id))

if __name__ == "__main__":
    cli()
